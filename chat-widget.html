<!DOCTYPE html>
<html lang="it">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Lia Aeon Chat</title>
<style>
* { margin:0; padding:0; box-sizing:border-box; }
body { 
  font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
  overflow:hidden;
  background:transparent;
}

#chat-button { 
  position: fixed; 
  bottom: 20px; 
  right: 20px; 
  width: 60px; 
  height: 60px; 
  border-radius: 50%; 
  background: linear-gradient(135deg,#667eea 0%,#764ba2 100%); 
  border:none; 
  cursor:pointer; 
  box-shadow:0 4px 12px rgba(0,0,0,0.15); 
  display:flex; 
  align-items:center; 
  justify-content:center; 
  z-index:10000; 
  transition: transform 0.3s ease;
  pointer-events:auto !important;
}
#chat-button:hover { transform:scale(1.1); }
#chat-button svg { width:30px; height:30px; fill:white; pointer-events:none; }

#chat-widget { 
  position: fixed; 
  bottom: 90px;
  right: 20px;
  width: 360px;
  height: 520px;
  background:white; 
  border-radius:16px;
  box-shadow:0 8px 32px rgba(0,0,0,0.2); 
  display:none; 
  flex-direction:column; 
  z-index:9999; 
  overflow:hidden; 
  animation:slideUp 0.3s ease-out;
}

@media (max-width:768px) {
  #chat-widget {
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    bottom: auto;
    right: auto;
    width: 90vw;
    max-width: 400px;
    height: 80vh;
    max-height: 600px;
  }
  
  #chat-button {
    bottom: 20px;
    right: 20px;
  }
  
  #chat-widget::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,0.5);
    z-index: -1;
  }
}

@keyframes slideUp { from{opacity:0;transform:translateY(20px);} to{opacity:1;transform:translateY(0);} }
#chat-widget.active { display:flex; }

#chat-header { background: linear-gradient(135deg,#667eea 0%,#764ba2 100%); color:white; padding:20px; display:flex; align-items:center; justify-content:space-between; }
.header-info { display:flex; align-items:center; gap:12px; position:relative; }
.avatar { width:45px; height:45px; border-radius:50%; background:linear-gradient(135deg,#f093fb 0%,#f5576c 100%); display:flex; align-items:center; justify-content:center; font-size:20px; font-weight:bold; border:2px solid white; overflow:hidden; color:white; position:relative; }
.avatar img { width:100%; height:100%; object-fit:cover; }
.online-badge { position:absolute; bottom:0; right:0; width:12px; height:12px; border-radius:50%; background:#4cd137; border:2px solid white; animation:pulse 1.2s infinite; transition:background 0.3s ease; }
.online-badge.typing { background:#f39c12; }
@keyframes pulse { 0%{transform:scale(0.8);}50%{transform:scale(1.2);}100%{transform:scale(0.8);} }
.header-text h3 { margin:0; font-size:16px; font-weight:600; }
.header-text p { margin:0; font-size:12px; opacity:0.9; }
#close-chat { background:none; border:none; color:white; font-size:24px; cursor:pointer; padding:0; width:30px; height:30px; display:flex; align-items:center; justify-content:center; border-radius:50%; transition:background 0.2s; }
#close-chat:hover { background:rgba(255,255,255,0.2); }

#messages { flex:1; overflow-y:auto; padding:20px; background:#f8f9fa; }
.message { margin-bottom:16px; display:flex; gap:10px; animation:fadeIn 0.3s ease-out; }
@keyframes fadeIn { from{opacity:0; transform:translateY(10px);} to{opacity:1; transform:translateY(0);} }
.message.bot { flex-direction:row; }
.message.user { flex-direction:row-reverse; }
.message-avatar { width:32px; height:32px; border-radius:50%; background:linear-gradient(135deg,#f093fb 0%,#f5576c 100%); display:flex; align-items:center; justify-content:center; font-size:14px; color:white; flex-shrink:0; overflow:hidden; position:relative; }
.message-avatar img { width:100%; height:100%; object-fit:cover; }
.message-avatar .online-badge { position:absolute; bottom:0; right:0; width:8px; height:8px; border-radius:50%; background:#4cd137; border:1.5px solid white; animation:pulse 1.2s infinite; transition:background 0.3s ease; }
.message-avatar .online-badge.typing { background:#f39c12; }
.message.user .message-avatar { background:linear-gradient(135deg,#667eea 0%,#764ba2 100%); }
.message-content { max-width:70%; padding:12px 16px; border-radius:16px; line-height:1.5; font-size:14px; }
.message.bot .message-content { background:white; color:#333; border-bottom-left-radius:4px; }
.message.user .message-content { background:linear-gradient(135deg,#667eea 0%,#764ba2 100%); color:white; border-bottom-right-radius:4px; }

#input-area { padding:16px; background:white; border-top:1px solid #e0e0e0; display:flex; gap:10px; }
#user-input { flex:1; padding:12px 16px; border:1px solid #e0e0e0; border-radius:24px; font-size:14px; outline:none; transition:border-color 0.2s; }
#user-input:focus { border-color:#667eea; }

/* BOTTONI VOCALE E INVIO */
.input-buttons { display:flex; gap:8px; }
#voice-button { 
  width:44px; 
  height:44px; 
  border-radius:50%; 
  background:#fff;
  border:2px solid #e0e0e0; 
  color:#667eea; 
  cursor:pointer; 
  display:flex; 
  align-items:center; 
  justify-content:center; 
  transition: all 0.3s;
}
#voice-button:hover { 
  border-color:#667eea;
  transform:scale(1.05); 
}
#voice-button.recording { 
  background:#ff4444;
  border-color:#ff4444;
  color:white;
  animation:recordPulse 1s infinite;
}
@keyframes recordPulse {
  0%, 100% { transform:scale(1); }
  50% { transform:scale(1.1); }
}
#voice-button.loading {
  background:#f39c12;
  border-color:#f39c12;
  color:white;
  pointer-events:none;
}

#send-button { 
  width:44px; 
  height:44px; 
  border-radius:50%; 
  background:linear-gradient(135deg,#667eea 0%,#764ba2 100%); 
  border:none; 
  color:white; 
  cursor:pointer; 
  display:flex; 
  align-items:center; 
  justify-content:center; 
  transition: transform 0.2s; 
}
#send-button:hover { transform:scale(1.05); }
#send-button:disabled { opacity:0.5; cursor:not-allowed; }

.typing-indicator { display:none; align-items:center; gap:10px; padding:12px 16px; background:white; border-radius:16px; width:fit-content; border-bottom-left-radius:4px; }
.typing-indicator.active { display:flex; }
.typing-dot { width:8px; height:8px; border-radius:50%; background:#999; animation:bounce 1.4s infinite; }
.typing-dot:nth-child(2) { animation-delay:0.2s; }
.typing-dot:nth-child(3) { animation-delay:0.4s; }
@keyframes bounce { 0%,60%,100%{transform:translateY(0);}30%{transform:translateY(-10px);} }

.error-message { background:#fee; color:#c33; padding:10px; border-radius:8px; margin:10px 0; font-size:12px; }
.info-message { background:#e3f2fd; color:#1976d2; padding:10px; border-radius:8px; margin:10px 0; font-size:12px; text-align:center; }

/* Selettore lingua */
#language-selector {
  position:absolute;
  top:12px;
  right:60px;
  display:flex;
  align-items:center;
  gap:8px;
  background:rgba(255,255,255,0.2);
  padding:6px 12px;
  border-radius:20px;
  backdrop-filter:blur(10px);
}
#language-selector label {
  font-size:16px;
  cursor:pointer;
}
#lang-select {
  background:rgba(255,255,255,0.3);
  border:none;
  color:white;
  padding:4px 8px;
  border-radius:12px;
  font-size:12px;
  cursor:pointer;
  outline:none;
  font-weight:500;
}
#lang-select option {
  background:#667eea;
  color:white;
}

/* Forma d'onda */
#waveform-container {
  display:none;
  position:absolute;
  bottom:80px;
  left:50%;
  transform:translateX(-50%);
  width:90%;
  max-width:320px;
  height:60px;
  background:rgba(255,255,255,0.95);
  border-radius:12px;
  padding:10px;
  box-shadow:0 4px 12px rgba(0,0,0,0.2);
  z-index:1000;
}
#waveform-container.active { display:block; }
#waveform-canvas {
  width:100%;
  height:100%;
  border-radius:6px;
}
/* Indicatore silenzio nella forma d'onda */
.waveform-label {
  position:absolute;
  top:-25px;
  left:50%;
  transform:translateX(-50%);
  background:#ff4444;
  color:white;
  padding:4px 12px;
  border-radius:12px;
  font-size:12px;
  font-weight:600;
  white-space:nowrap;
  animation:recordPulse 1s infinite;
  transition:background 0.3s;
}
.waveform-label.silent {
  background:#ffa500;
  animation:none;
}
#model-loading-overlay {
  position:absolute;
  top:0;
  left:0;
  right:0;
  bottom:0;
  background:rgba(255,255,255,0.95);
  display:none;
  align-items:center;
  justify-content:center;
  z-index:10000;
  flex-direction:column;
  gap:20px;
}
#model-loading-overlay.active { display:flex; }
.loading-spinner {
  width:50px;
  height:50px;
  border:4px solid #e0e0e0;
  border-top:4px solid #667eea;
  border-radius:50%;
  animation:spin 1s linear infinite;
}
@keyframes spin {
  to { transform:rotate(360deg); }
}
.loading-text {
  font-size:14px;
  color:#666;
  text-align:center;
  max-width:250px;
}
</style>
</head>
<body>

<button id="chat-button" aria-label="Apri chat">
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 2H4c-1.1 0-2 .9-2 2v18l4-4h14c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2z"/></svg>
</button>

<div id="chat-widget">
  <!-- Overlay caricamento modello -->
  <div id="model-loading-overlay">
    <div class="loading-spinner"></div>
    <div class="loading-text">Caricamento modello vocale...<br>Attendere circa 30 secondi</div>
  </div>

  <!-- Selettore lingua -->
  <div id="language-selector">
    <label for="lang-select">üåê</label>
    <select id="lang-select" title="Seleziona lingua">
      <option value="italian">üáÆüáπ Italiano</option>
      <option value="english">üá¨üáß English</option>
      <option value="spanish">üá™üá∏ Espa√±ol</option>
      <option value="french">üá´üá∑ Fran√ßais</option>
      <option value="german">üá©üá™ Deutsch</option>
    </select>
  </div>

  <div id="chat-header">
    <div class="header-info">
      <div class="avatar">
        <img src="lia.jpg" alt="Lia Aeon" onerror="this.style.display='none'; this.parentElement.textContent='LA'">
        <div class="online-badge" id="header-badge"></div>
      </div>
      <div class="header-text">
        <h3>Lia Aeon</h3>
        <p>Assistente Virtuale</p>
      </div>
    </div>
    <button id="close-chat" aria-label="Chiudi chat">√ó</button>
  </div>

  <div id="messages"></div>

  <!-- Contenitore forma d'onda -->
  <div id="waveform-container">
    <div class="waveform-label">‚óè REGISTRAZIONE IN CORSO</div>
    <canvas id="waveform-canvas"></canvas>
  </div>

  <div id="input-area">
    <input type="text" id="user-input" placeholder="Scrivi o parla..." autocomplete="off" />
    <div class="input-buttons">
      <button id="voice-button" aria-label="Registra messaggio vocale" title="Registra messaggio vocale">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="currentColor">
          <path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z"/>
          <path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/>
        </svg>
      </button>
      <button id="send-button" aria-label="Invia messaggio">
        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="white">
          <path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/>
        </svg>
      </button>
    </div>
  </div>
</div>

<script type="module">
import { pipeline, env } from 'https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.2';

// Configura ambiente
env.allowLocalModels = false;
env.allowRemoteModels = true;
env.backends.onnx.wasm.numThreads = 1;

const BACKEND_URL = 'https://mirthlessly-noncrustaceous-alisa.ngrok-free.dev/api/chat';
const conversationHistory = [];
let typingIndicatorVisible = false;
let lastSentTime = 0;

// Variabili vocali
let transcriber = null;
let mediaRecorder = null;
let audioChunks = [];
let isRecording = false;
let isModelLoading = false;
let currentLanguage = 'italian';
let audioContext = null;
let analyser = null;
let animationId = null;
let silenceDetectionInterval = null;
let lastSoundTime = 0;
const SILENCE_THRESHOLD = 1000; // 2 secondi di silenzio
const VOLUME_THRESHOLD = 0.01; // Soglia volume per considerare "suono"

// Suoni feedback
const audioFeedback = {
  start: null,
  stop: null
};

// Crea suoni di feedback
function createAudioFeedback() {
  const ctx = new (window.AudioContext || window.webkitAudioContext)();
  
  // Suono di inizio (beep corto)
  const startBuffer = ctx.createBuffer(1, ctx.sampleRate * 0.1, ctx.sampleRate);
  const startData = startBuffer.getChannelData(0);
  for (let i = 0; i < startData.length; i++) {
    startData[i] = Math.sin(2 * Math.PI * 800 * i / ctx.sampleRate) * 0.3;
  }
  audioFeedback.start = startBuffer;
  
  // Suono di fine (beep doppio)
  const stopBuffer = ctx.createBuffer(1, ctx.sampleRate * 0.15, ctx.sampleRate);
  const stopData = stopBuffer.getChannelData(0);
  for (let i = 0; i < stopData.length; i++) {
    const freq = i < stopData.length / 2 ? 600 : 800;
    stopData[i] = Math.sin(2 * Math.PI * freq * i / ctx.sampleRate) * 0.3;
  }
  audioFeedback.stop = stopBuffer;
  
  return ctx;
}

function playFeedback(type) {
  try {
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const source = ctx.createBufferSource();
    source.buffer = audioFeedback[type];
    source.connect(ctx.destination);
    source.start(0);
  } catch (e) {
    console.log('Audio feedback non disponibile');
  }
}

const chatButton = document.getElementById('chat-button');
const chatWidget = document.getElementById('chat-widget');
const closeChat = document.getElementById('close-chat');
const sendButton = document.getElementById('send-button');
const voiceButton = document.getElementById('voice-button');
const userInput = document.getElementById('user-input');
const messagesContainer = document.getElementById('messages');
const headerBadge = document.getElementById('header-badge');
const modelLoadingOverlay = document.getElementById('model-loading-overlay');
const langSelect = document.getElementById('lang-select');
const waveformContainer = document.getElementById('waveform-container');
const waveformCanvas = document.getElementById('waveform-canvas');

// Inizializza suoni
createAudioFeedback();

// Mappa lingue -> modelli (modelli pi√π grandi per migliore accuratezza)
const languageModels = {
  italian: ['Xenova/whisper-small', 'Xenova/whisper-base', 'Xenova/whisper-tiny'],
  english: ['Xenova/whisper-small.en', 'Xenova/whisper-base.en', 'Xenova/whisper-tiny.en'],
  spanish: ['Xenova/whisper-small', 'Xenova/whisper-base', 'Xenova/whisper-tiny'],
  french: ['Xenova/whisper-small', 'Xenova/whisper-base', 'Xenova/whisper-tiny'],
  german: ['Xenova/whisper-small', 'Xenova/whisper-base', 'Xenova/whisper-tiny']
};

// Cambio lingua
langSelect.addEventListener('change', async (e) => {
  currentLanguage = e.target.value;
  // Ricarica modello se gi√† caricato
  if (transcriber) {
    transcriber = null;
    addInfoMessage(`Lingua cambiata: ${e.target.options[e.target.selectedIndex].text}`);
  }
});

function notifyParent(action) {
  if (window.parent !== window) {
    window.parent.postMessage(action, '*');
  }
}

chatButton.addEventListener('click', () => {
  chatWidget.classList.add('active');
  chatButton.style.display = 'none';
  notifyParent('chat-opened');
  if (window.parent !== window) {
    window.parent.postMessage('enable-pointer-events', '*');
  }
  if (messagesContainer.children.length === 0) sendWelcomeMessage();
});

closeChat.addEventListener('click', () => {
  chatWidget.classList.remove('active');
  chatButton.style.display = 'flex';
  notifyParent('chat-closed');
  if (window.parent !== window) {
    window.parent.postMessage('disable-pointer-events', '*');
  }
});

sendButton.addEventListener('click', handleSendMessage);
userInput.addEventListener('keypress', (e) => {
  if (e.key === 'Enter' && !e.shiftKey) {
    e.preventDefault();
    handleSendMessage();
  }
});

// GESTIONE VOCALE
voiceButton.addEventListener('click', handleVoiceClick);

async function handleVoiceClick() {
  if (isRecording) {
    stopRecording();
  } else {
    startRecording();
  }
}

async function startRecording() {
  try {
    // Carica modello se necessario
    if (!transcriber && !isModelLoading) {
      await loadModel();
    }
    
    if (!transcriber) {
      addInfoMessage('Modello vocale non ancora pronto. Riprova tra qualche secondo.');
      return;
    }

    // Richiedi audio di alta qualit√†
    const stream = await navigator.mediaDevices.getUserMedia({ 
      audio: {
        channelCount: 1,
        sampleRate: 16000,
        echoCancellation: true,
        noiseSuppression: true,
        autoGainControl: true
      }
    });
    
    // Setup visualizzatore
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    analyser = audioContext.createAnalyser();
    const source = audioContext.createMediaStreamSource(stream);
    source.connect(analyser);
    analyser.fftSize = 256;
    
    // Mostra forma d'onda
    waveformContainer.classList.add('active');
    drawWaveform();
    
    // Inizia rilevamento silenzio
    lastSoundTime = Date.now();
    startSilenceDetection();
    
    mediaRecorder = new MediaRecorder(stream, {
      mimeType: 'audio/webm;codecs=opus',
      audioBitsPerSecond: 128000
    });
    audioChunks = [];
    
    mediaRecorder.ondataavailable = (event) => {
      audioChunks.push(event.data);
    };
    
    mediaRecorder.onstop = async () => {
      const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
      await processAudio(audioBlob);
      
      // Ferma visualizzatore e rilevamento silenzio
      waveformContainer.classList.remove('active');
      if (animationId) cancelAnimationFrame(animationId);
      stopSilenceDetection();
      
      // Ferma lo stream
      stream.getTracks().forEach(track => track.stop());
      if (audioContext) audioContext.close();
    };
    
    mediaRecorder.start();
    isRecording = true;
    voiceButton.classList.add('recording');
    voiceButton.title = 'Parlando... (max 30s, si ferma dopo 2s di silenzio)';
    
    // Feedback sonoro
    playFeedback('start');
    
    // Safety: ferma dopo 30 secondi massimo
    setTimeout(() => {
      if (isRecording) {
        console.log('‚è±Ô∏è Timeout 30 secondi raggiunto');
        stopRecording();
        addInfoMessage('Registrazione fermata automaticamente dopo 30 secondi.');
      }
    }, 30000);
    
  } catch (error) {
    console.error('Errore microfono:', error);
    addErrorMessage('Impossibile accedere al microfono. Verifica i permessi del browser.');
  }
}

function startSilenceDetection() {
  const bufferLength = analyser.frequencyBinCount;
  const dataArray = new Uint8Array(bufferLength);
  
  silenceDetectionInterval = setInterval(() => {
    if (!isRecording || !analyser) {
      stopSilenceDetection();
      return;
    }
    
    // Analizza il volume corrente
    analyser.getByteTimeDomainData(dataArray);
    
    // Calcola RMS (Root Mean Square) per volume
    let sum = 0;
    for (let i = 0; i < bufferLength; i++) {
      const normalized = (dataArray[i] - 128) / 128;
      sum += normalized * normalized;
    }
    const rms = Math.sqrt(sum / bufferLength);
    
    // Se c'√® suono, aggiorna timestamp
    if (rms > VOLUME_THRESHOLD) {
      lastSoundTime = Date.now();
    }
    
    // Controlla se √® passato troppo tempo senza suono
    const silenceDuration = Date.now() - lastSoundTime;
    
    if (silenceDuration > SILENCE_THRESHOLD) {
      console.log('üîá Silenzio rilevato per 2 secondi, fermo registrazione');
      stopRecording();
    }
  }, 100); // Controlla ogni 100ms
}

function stopSilenceDetection() {
  if (silenceDetectionInterval) {
    clearInterval(silenceDetectionInterval);
    silenceDetectionInterval = null;
  }
}

function drawWaveform() {
  const canvas = waveformCanvas;
  const ctx = canvas.getContext('2d');
  const width = canvas.width = canvas.offsetWidth * window.devicePixelRatio;
  const height = canvas.height = canvas.offsetHeight * window.devicePixelRatio;
  
  ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
  
  const bufferLength = analyser.frequencyBinCount;
  const dataArray = new Uint8Array(bufferLength);
  const waveformLabel = document.querySelector('.waveform-label');
  
  function draw() {
    animationId = requestAnimationFrame(draw);
    
    analyser.getByteTimeDomainData(dataArray);
    
    // Calcola volume RMS per indicatore silenzio
    let sum = 0;
    for (let i = 0; i < bufferLength; i++) {
      const normalized = (dataArray[i] - 128) / 128;
      sum += normalized * normalized;
    }
    const rms = Math.sqrt(sum / bufferLength);
    
    // Aggiorna indicatore visivo silenzio
    const silenceDuration = Date.now() - lastSoundTime;
    const silencePercent = Math.min(100, (silenceDuration / SILENCE_THRESHOLD) * 100);
    
    if (waveformLabel) {
      if (silenceDuration > 500) {
        waveformLabel.classList.add('silent');
        const remaining = Math.ceil((SILENCE_THRESHOLD - silenceDuration) / 1000);
        waveformLabel.textContent = `‚è∏Ô∏è SILENZIO (fermo tra ${remaining}s)`;
      } else {
        waveformLabel.classList.remove('silent');
        waveformLabel.textContent = '‚óè REGISTRAZIONE IN CORSO';
      }
    }
    
    ctx.fillStyle = '#f8f9fa';
    ctx.fillRect(0, 0, width, height);
    
    // Colore onda basato su volume
    const waveColor = rms > VOLUME_THRESHOLD ? '#667eea' : '#cccccc';
    ctx.lineWidth = 2;
    ctx.strokeStyle = waveColor;
    ctx.beginPath();
    
    const sliceWidth = width / bufferLength;
    let x = 0;
    
    for (let i = 0; i < bufferLength; i++) {
      const v = dataArray[i] / 128.0;
      const y = v * height / 2;
      
      if (i === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
      
      x += sliceWidth;
    }
    
    ctx.lineTo(width, height / 2);
    ctx.stroke();
    
    // Barra progresso silenzio
    if (silenceDuration > 500) {
      ctx.fillStyle = '#ffa500';
      ctx.fillRect(0, height - 4, (width * silencePercent / 100), 4);
    }
  }
  
  draw();
}

function stopRecording() {
  if (mediaRecorder && isRecording) {
    mediaRecorder.stop();
    isRecording = false;
    voiceButton.classList.remove('recording');
    voiceButton.classList.add('loading');
    voiceButton.title = 'Elaborazione in corso...';
    
    // Ferma rilevamento silenzio
    stopSilenceDetection();
    
    // Feedback sonoro
    playFeedback('stop');
  }
}

async function loadModel() {
  if (isModelLoading) return;
  
  isModelLoading = true;
  modelLoadingOverlay.classList.add('active');
  
  const models = languageModels[currentLanguage];
  let loadedModel = null;
  let lastError = null;
  
  const loadingText = document.querySelector('.loading-text');
  
  // Prova i modelli in ordine
  for (let i = 0; i < models.length; i++) {
    const modelName = models[i];
    try {
      console.log(`[${i+1}/${models.length}] Caricamento: ${modelName}`);
      
      if (loadingText) {
        loadingText.innerHTML = `Caricamento modello vocale...<br>Tentativo ${i+1} di ${models.length}<br><small>${modelName}</small>`;
      }
      
      // Timeout di 60 secondi per modello
      const timeoutPromise = new Promise((_, reject) => 
        setTimeout(() => reject(new Error('Timeout caricamento')), 60000)
      );
      
      const loadPromise = pipeline(
        'automatic-speech-recognition',
        modelName,
        {
          quantized: true,
          device: 'auto',
          dtype: {
            encoder_model: 'fp32',  // Maggiore precisione
            decoder_model_merged: 'q8'
          }
        }
      );
      
      loadedModel = await Promise.race([loadPromise, timeoutPromise]);
      
      // Se arriviamo qui, il modello √® caricato
      transcriber = loadedModel;
      console.log(`‚úì Successo: ${modelName}`);
      
      if (loadingText) {
        loadingText.innerHTML = `‚úì Modello caricato!<br>Riconoscimento vocale pronto`;
      }
      
      setTimeout(() => {
        modelLoadingOverlay.classList.remove('active');
        addInfoMessage(`‚úì Riconoscimento vocale attivo!`);
      }, 1000);
      
      isModelLoading = false;
      return;
      
    } catch (error) {
      console.warn(`‚úó Fallito ${modelName}:`, error.message);
      lastError = error;
      
      if (loadingText) {
        loadingText.innerHTML = `Errore con ${modelName.split('/')[1]}<br>Provo alternativa...`;
      }
      
      await new Promise(resolve => setTimeout(resolve, 1000));
      continue;
    }
  }
  
  // Se arriviamo qui, tutti i modelli hanno fallito
  modelLoadingOverlay.classList.remove('active');
  isModelLoading = false;
  
  console.error('‚ùå Tutti i modelli falliti. Ultimo errore:', lastError);
  
  // Diagnostica dettagliata
  const errorDetails = [];
  errorDetails.push('Dettagli errore:');
  errorDetails.push(`- Browser: ${navigator.userAgent.includes('Chrome') ? 'Chrome' : navigator.userAgent.includes('Firefox') ? 'Firefox' : 'Altro'}`);
  errorDetails.push(`- Online: ${navigator.onLine ? 'S√¨' : 'NO'}`);
  errorDetails.push(`- Ultimo errore: ${lastError?.message || 'Sconosciuto'}`);
  
  console.error(errorDetails.join('\n'));
  
  addErrorMessage('Impossibile caricare il modello vocale. Cause possibili:\n‚Ä¢ Connessione internet instabile\n‚Ä¢ Browser non supportato\n‚Ä¢ Estensioni che bloccano il download');
  
  // Suggerisci alternative
  setTimeout(() => {
    addInfoMessage('üí° Suggerimento: Usa la digitazione manuale o ricarica la pagina con buona connessione internet.');
  }, 2000);
}

async function processAudio(audioBlob) {
  try {
    // Limita dimensione audio (max 30 secondi)
    const maxSize = 30 * 16000 * 2; // 30 secondi a 16kHz, 2 bytes per sample
    if (audioBlob.size > maxSize) {
      addErrorMessage('Registrazione troppo lunga. Massimo 30 secondi.');
      voiceButton.classList.remove('loading');
      voiceButton.title = 'Registra messaggio vocale';
      return;
    }
    
    // Converti blob in ArrayBuffer
    const arrayBuffer = await audioBlob.arrayBuffer();
    
    // Decodifica audio
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const audioBuffer = await ctx.decodeAudioData(arrayBuffer);
    
    // Verifica durata
    if (audioBuffer.duration > 30) {
      addErrorMessage('Registrazione troppo lunga. Parla per massimo 30 secondi.');
      voiceButton.classList.remove('loading');
      voiceButton.title = 'Registra messaggio vocale';
      return;
    }
    
    // Estrai dati audio (mono, 16kHz)
    let audioData = audioBuffer.getChannelData(0);
    
    // Limita lunghezza array
    const maxSamples = 30 * 16000; // 30 secondi a 16kHz
    if (audioData.length > maxSamples) {
      console.warn('Audio troncato a 30 secondi');
      audioData = audioData.slice(0, maxSamples);
    }
    
    // Resample a 16kHz se necessario
    if (audioBuffer.sampleRate !== 16000) {
      console.log(`Resampling da ${audioBuffer.sampleRate}Hz a 16000Hz...`);
      audioData = resampleAudio(audioData, audioBuffer.sampleRate, 16000);
    }
    
    // Normalizza audio in chunks per evitare stack overflow
    const chunkSize = 4096;
    let maxAmplitude = 0;
    
    for (let i = 0; i < audioData.length; i += chunkSize) {
      const end = Math.min(i + chunkSize, audioData.length);
      for (let j = i; j < end; j++) {
        maxAmplitude = Math.max(maxAmplitude, Math.abs(audioData[j]));
      }
    }
    
    if (maxAmplitude > 0) {
      const normalizedData = new Float32Array(audioData.length);
      for (let i = 0; i < audioData.length; i += chunkSize) {
        const end = Math.min(i + chunkSize, audioData.length);
        for (let j = i; j < end; j++) {
          normalizedData[j] = audioData[j] / maxAmplitude * 0.95;
        }
      }
      audioData = normalizedData;
    }
    
    // Trascrivi con opzioni ottimizzate
    console.log(`Trascrizione ${audioData.length} samples...`);
    
    const result = await transcriber(audioData, {
      language: currentLanguage === 'italian' ? 'italian' : 
                currentLanguage === 'english' ? 'english' :
                currentLanguage === 'spanish' ? 'spanish' :
                currentLanguage === 'french' ? 'french' :
                currentLanguage === 'german' ? 'german' : 'italian',
      task: 'transcribe',
      chunk_length_s: 30,
      stride_length_s: 5,
      return_timestamps: false,
      temperature: 0.0,
      compression_ratio_threshold: 2.4,
      logprob_threshold: -1.0,
      no_speech_threshold: 0.6
    });
    
    let transcription = result.text.trim();
    
    // Post-processing per italiano
    if (currentLanguage === 'italian') {
      transcription = postProcessItalian(transcription);
    }
    
    voiceButton.classList.remove('loading');
    voiceButton.title = 'Registra messaggio vocale';
    
    if (transcription && transcription.length > 0) {
      console.log('Trascrizione:', transcription);
      userInput.value = transcription;
      userInput.focus();
      
      // Mostra preview prima di inviare
      addInfoMessage(`üìù Trascritto: "${transcription}"`);
      
      // Invia dopo 2 secondi (tempo per correggere se necessario)
      setTimeout(() => {
        if (userInput.value === transcription) {
          handleSendMessage();
        }
      }, 2000);
    } else {
      addInfoMessage('Non ho capito. Riprova parlando pi√π chiaramente e pi√π vicino al microfono.');
    }
    
  } catch (error) {
    console.error('Errore elaborazione audio:', error);
    console.error('Stack trace:', error.stack);
    voiceButton.classList.remove('loading');
    voiceButton.title = 'Registra messaggio vocale';
    
    // Messaggio pi√π specifico
    if (error.message.includes('stack')) {
      addErrorMessage('Audio troppo lungo o complesso. Prova con frasi pi√π brevi (max 20 secondi).');
    } else {
      addErrorMessage(`Errore trascrizione: ${error.message || 'Riprova con audio pi√π breve'}`);
    }
  }
}

// Post-processing per migliorare trascrizioni italiane
function postProcessItalian(text) {
  let result = text;
  
  // Correzioni comuni
  const corrections = {
    // Nomi propri spesso sbagliati
    'se√±or': 'signor',
    'senor': 'signor',
    'se√±ora': 'signora',
    'di no': 'Dino',
    'dino': 'Dino',
    'risi': 'Risi',
    
    // Correzioni comuni
    'sono il': 'Sono il',
    'sono la': 'Sono la',
    'mi chiamo': 'Mi chiamo',
    'buongiorno': 'Buongiorno',
    'buonasera': 'Buonasera',
    
    // Rimuovi artefatti comuni
    'um': '',
    'uh': '',
    'eh': '',
    'mm': ''
  };
  
  // Applica correzioni
  for (const [wrong, correct] of Object.entries(corrections)) {
    const regex = new RegExp(wrong, 'gi');
    result = result.replace(regex, correct);
  }
  
  // Capitalizza prima lettera
  result = result.charAt(0).toUpperCase() + result.slice(1);
  
  // Pulisci spazi multipli
  result = result.replace(/\s+/g, ' ').trim();
  
  // Aggiungi punto finale se manca
  if (!/[.!?]$/.test(result)) {
    result += '.';
  }
  
  return result;
}

function resampleAudio(audioData, originalRate, targetRate) {
  if (originalRate === targetRate) {
    return audioData;
  }
  
  const ratio = originalRate / targetRate;
  const newLength = Math.round(audioData.length / ratio);
  const result = new Float32Array(newLength);
  
  // Usa chunks per evitare stack overflow
  const chunkSize = 4096;
  
  for (let start = 0; start < newLength; start += chunkSize) {
    const end = Math.min(start + chunkSize, newLength);
    
    for (let i = start; i < end; i++) {
      const srcIndex = i * ratio;
      const srcIndexFloor = Math.floor(srcIndex);
      const srcIndexCeil = Math.min(srcIndexFloor + 1, audioData.length - 1);
      const weight = srcIndex - srcIndexFloor;
      
      result[i] = audioData[srcIndexFloor] * (1 - weight) + audioData[srcIndexCeil] * weight;
    }
  }
  
  return result;
}

function sendWelcomeMessage() {
  setTimeout(() => {
    addBotMessage("Salve, mi chiamo Lia, sono la segretaria virtuale del dottor Aniello Starace. Con chi ho il piacere di parlare?");
  }, 300);
}

async function handleSendMessage() {
  const now = Date.now();
  if (now - lastSentTime < 800) return;
  lastSentTime = now;

  const message = userInput.value.trim();
  if (!message) return;
  
  userInput.disabled = true;
  sendButton.disabled = true;
  voiceButton.disabled = true;
  
  addUserMessage(message);
  userInput.value = '';
  conversationHistory.push({ role: 'user', content: message });
  showTypingIndicator();

  try {
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), 30000);

    const response = await fetch(BACKEND_URL, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ message, conversationHistory }),
      signal: controller.signal
    });
    
    clearTimeout(timeout);
    hideTypingIndicator();
    
    if (response.ok) {
      const data = await response.json();
      if (data.response) {
        addBotMessage(data.response);
        conversationHistory.push({ role: 'assistant', content: data.response });
      } else {
        addBotMessage("Mi dispiace, si √® verificato un errore. Riprovi per favore.");
      }
    } else {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
  } catch (error) {
    hideTypingIndicator();
    addErrorMessage("Impossibile connettersi al server. Verifichi la connessione e riprovi.");
  } finally {
    userInput.disabled = false;
    sendButton.disabled = false;
    voiceButton.disabled = false;
    userInput.focus();
  }
}

function addUserMessage(text) {
  const div = document.createElement('div');
  div.className = 'message user';
  div.innerHTML = `<div class="message-avatar">Tu</div><div class="message-content">${escapeHtml(text)}</div>`;
  messagesContainer.appendChild(div);
  scrollToBottom();
}

function addBotMessage(text) {
  const div = document.createElement('div');
  div.className = 'message bot';
  div.innerHTML = `<div class="message-avatar"><img src="lia.jpg" alt="Lia" onerror="this.style.display='none'; this.parentElement.textContent='LA'"><div class="online-badge"></div></div><div class="message-content">${escapeHtml(text)}</div>`;
  messagesContainer.appendChild(div);
  scrollToBottom();
}

function addErrorMessage(text) {
  const div = document.createElement('div');
  div.className = 'error-message';
  div.textContent = text;
  messagesContainer.appendChild(div);
  scrollToBottom();
}

function addInfoMessage(text) {
  const div = document.createElement('div');
  div.className = 'info-message';
  div.textContent = text;
  messagesContainer.appendChild(div);
  scrollToBottom();
}

function showTypingIndicator() {
  if (typingIndicatorVisible) return;
  typingIndicatorVisible = true;
  headerBadge.classList.add('typing');
  const div = document.createElement('div');
  div.className = 'message bot';
  div.id = 'typing-indicator-msg';
  div.innerHTML = `<div class="message-avatar"><img src="lia.jpg" alt="Lia" onerror="this.style.display='none'; this.parentElement.textContent='LA'"><div class="online-badge typing"></div></div><div class="typing-indicator active"><div class="typing-dot"></div><div class="typing-dot"></div><div class="typing-dot"></div></div>`;
  messagesContainer.appendChild(div);
  scrollToBottom();
}

function hideTypingIndicator() {
  const indicator = document.getElementById('typing-indicator-msg');
  if (indicator) indicator.remove();
  headerBadge.classList.remove('typing');
  typingIndicatorVisible = false;
}

function scrollToBottom() {
  requestAnimationFrame(() => {
    messagesContainer.scrollTop = messagesContainer.scrollHeight;
  });
}

function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

// Precarica il modello quando la chat viene aperta
let modelPreloaded = false;
const originalChatButtonClick = chatButton.onclick;

chatButton.addEventListener('click', () => {
  if (!modelPreloaded && !transcriber && !isModelLoading) {
    modelPreloaded = true;
    console.log('üé§ Inizio precaricamento modello vocale...');
    
    // Attendi 2 secondi poi carica
    setTimeout(() => {
      if (!transcriber && !isModelLoading) {
        loadModel();
      }
    }, 2000);
  }
});

// Test di connettivit√† all'avvio
async function testConnectivity() {
  try {
    const response = await fetch('https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.2/package.json', {
      method: 'HEAD',
      cache: 'no-store'
    });
    console.log('‚úì CDN raggiungibile:', response.ok);
    return response.ok;
  } catch (error) {
    console.error('‚úó CDN non raggiungibile:', error);
    return false;
  }
}

// Test al caricamento pagina
testConnectivity().then(ok => {
  if (!ok) {
    console.warn('‚ö†Ô∏è Problemi di connettivit√† rilevati');
  }
});
</script>

</body>
</html>

